use std::mem;


pub mod ffi;
pub mod safe;

mod conversion;

extern "C" {

    /// Implement this function (and impl_serialize_resp) to have your plugin
    /// register as having a Listener module
    /// 
    /// Deserializes request recieved on associated UDP socket into a DNS protocol
    /// message with queries to be resolved
    pub fn impl_deserialize_req(req: *const u8, size: usize, message: *mut ffi::DnsMessage);

    /// Implement this function (and impl_deserialize_req) to have your plugin
    /// register as having a Listener module
    /// 
    /// Serializes responses generated by the resolver into a response to send
    /// back to the requester over the original UDP socket
    pub fn impl_serialize_resp(resp: ffi::DnsMessage) -> ffi::SerializerResponse;

    /// Implement this function for your plugin to register as having a Resolver module.
    /// 
    /// Resolves a request generated by the Listener into a response message, likely
    /// by querying (an) upstream resolver(s)
    pub fn impl_resolve_req(req: ffi::DnsMessage) -> ffi::DnsMessage;
}

#[repr(C)]
#[derive(Debug)]
pub enum DnsField {
    Question,
    Answer,
    Authority,
    Additional
}

/// Safely resize the requests field of the provided struct, and set the appropriate header field.
/// 
/// This funciton should always be used to add and remove fields to the message struct,
/// so that all memory that is persistent across calls to your plugin is handled consistently.
#[no_mangle]
pub extern "C" fn resize_field(msg_ptr: *mut ffi::DnsMessage, num: u16, field: DnsField) {
    let Some(msg) = (unsafe { msg_ptr.as_mut() }) else { return };

    match field {
        DnsField::Question => {
            let mut request_vec = if msg.question.is_null() {
                Vec::with_capacity(0)
            } else {
                unsafe {
                    Vec::from_raw_parts(
                        msg.question,
                        msg.header.qdcount.into(),
                        msg.header.qdcount.into()
                    )
                }
            };

            request_vec.resize_with(num.into(), Default::default);

            let mut request_vec = mem::ManuallyDrop::new(request_vec);

            msg.question = request_vec.as_mut_ptr();

            msg.header.qdcount = num;

        },
        DnsField::Answer => {
            let mut answer_vec = if msg.answer.is_null() {
                Vec::with_capacity(0)
            } else {
                unsafe {
                    Vec::from_raw_parts(
                        msg.answer,
                        msg.header.ancount.into(),
                        msg.header.ancount.into()
                    )
                }
            };

            answer_vec.resize_with(num.into(), Default::default);

            let mut answer_vec = mem::ManuallyDrop::new(answer_vec);

            msg.answer = answer_vec.as_mut_ptr();

            msg.header.ancount = num;
        },
        DnsField::Authority => {
            let mut auth_vec = if msg.answer.is_null() {
                Vec::with_capacity(0)
            } else {
                unsafe {
                    Vec::from_raw_parts(
                        msg.authority,
                        msg.header.nscount.into(),
                        msg.header.nscount.into()
                    )
                }
            };

            auth_vec.resize_with(num.into(), Default::default);

            let mut auth_vec = mem::ManuallyDrop::new(auth_vec);

            msg.answer = auth_vec.as_mut_ptr();

            msg.header.ancount = num;

        },
        DnsField::Additional => {
            let mut additional_vec = if msg.answer.is_null() {
                Vec::with_capacity(0)
            } else {
                unsafe {
                    Vec::from_raw_parts(
                        msg.additional,
                        msg.header.arcount.into(),
                        msg.header.arcount.into()
                    )
                }
            };

            additional_vec.resize_with(num.into(), Default::default);

            let mut additional_vec = mem::ManuallyDrop::new(additional_vec);

            msg.answer = additional_vec.as_mut_ptr();

            msg.header.ancount = num;

        },
    }
}